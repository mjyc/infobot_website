#!/usr/bin/env python

'''This node schedules, executes and cancels QueryJobs and executes
them. Schedulring algorithm is based on "timeissued" fields (FIFO).
'''

# ######################################################################
# Imports
# ######################################################################

import rospy

# System builtins
from datetime import datetime as dt
from pytz import utc

# ROS
import actionlib
from actionlib_msgs.msg import GoalStatus

# SARA
from bson.objectid import ObjectId
from pymongo import MongoClient

# Local
from sara_uw_website.msg import (
    RunQueryAction, RunQueryGoal, RunQueryResult, QueryJob, Result, User
)
from sara_uw_website.srv import (
    CancelQueryJob,
    CancelQueryJobResponse,
    ScheduleQueryJob,
    ScheduleQueryJobResponse
)


# ######################################################################
# Module level constants, functions
# ######################################################################

RECEIVED = QueryJob.STATUS_RECEIVED
SCHEDULED = QueryJob.STATUS_SCHEDULED
RUNNING = QueryJob.STATUS_RUNNING
SUCCEEDED = QueryJob.STATUS_SUCCEEDED
CANCELLED = QueryJob.STATUS_CANCELLED
FAILED = QueryJob.STATUS_FAILED


def torostime(t):
    ''' Converts datetime.datetime object to rospy.rostime.Time object.
    '''

    if t:
        s = (t - dt(1970, 1, 1).replace(tzinfo=utc)).total_seconds()
    else:
        s = 0
    return rospy.Time(s)

def torosresult(r):
    ''' Converts queryjob.result retrieved from DB to
    sara_uw_website/Result msg.
    '''

    if r:
        return Result(r["text"], r["confidence"], r["img_path"])
    else:
        return Result()

def torosuser(u):
    ''' Converts queryjob.result retrieved from DB to
    sara_uw_website/Result msg.
    '''

    print u
    if u:
        return User(u["email"], u["name"])
    else:
        return User()

def torosqueryjob(queryjob):
    ''' Converts queryjob retrieved from DB to sara_uw_website/QueryJob
    msg.
    '''

    msg = QueryJob()
    msg.id = str(queryjob["_id"])

    msg.timeissued = torostime(queryjob["timeissued"])
    msg.typed_cmd = queryjob["typed_cmd"]
    msg.notification_sms = queryjob["notification_sms"]
    msg.notification_email = queryjob["notification_email"]
    msg.is_public = queryjob["is_public"]
    msg.deadline = torostime(queryjob["deadline"])
    msg.user = torosuser(queryjob["user"])

    msg.status = queryjob["status"]
    msg.order = queryjob["order"]
    msg.timestarted = torostime(queryjob["timestarted"])
    msg.timecompleted = torostime(queryjob["timecompleted"])
    msg.result = torosresult(queryjob["result"])

    return msg


# ######################################################################
# Classes
# ######################################################################
class QueryJobScheduler:

    def __init__(self):
        rospy.init_node("queryjob_scheduler")

        # Connect to DB.
        host = rospy.get_param("~host", "localhost")
        port = rospy.get_param("~port", 27017)
        dbname = rospy.get_param("~dbname", "sara_uw_website")
        collname = rospy.get_param("~collname", "queryjobs")
        client = MongoClient(host, port, tz_aware=True)
        db = client[dbname]
        self._collection = db[collname]

        # ROS Service and Publisher.
        rospy.Service(
            "/schedule_queryjob", ScheduleQueryJob,
            self.handle_schedule_queryjob)
        rospy.Service(
            "/cancel_queryjob", CancelQueryJob,
            self.handle_cancel_queryjob)
        self._pub = rospy.Publisher(
            '/updated_queryjob', QueryJob, queue_size=10000)

        # ROS SimpleActionClient.
        self._ac = actionlib.SimpleActionClient("/run_query", RunQueryAction)
        self.execute_queryjobs()

    def handle_cancel_queryjob(self, req):
        # Parse input.
        queryjob_id = ObjectId(req.queryjob_id)

        # Set to cancel and log.
        query = {"_id": queryjob_id}
        update = {"$set": {
            "status": CANCELLED,
            "timecompleted": dt.utcnow().replace(tzinfo=utc)
        }}
        q = self._collection.find_and_modify(query, update)
        if not q:
            return CancelQueryJobResponse(False)

        # Extra step is needed for running jobs.
        if q["status"] == RUNNING:
            if self._ac.get_state() != GoalStatus.ACTIVE:
                rospy.logerr("The goal MUST be active!")
                return CancelQueryJobResponse(False)
            self._ac.cancel_goal()

        return CancelQueryJobResponse(True)

    def handle_schedule_queryjob(self, req):
        # Input processing.
        queryjob_id = ObjectId(req.queryjob_id)
        timeissued = dt.utcfromtimestamp(req.timeissued).replace(tzinfo=utc)

        # Prevent multiple scheduling.
        qr = self._collection.find({
            "_id": queryjob_id,
            # "timeissued" field can be overwritten.
            "order": {"$ne": None},
            "timestarted": {"$ne": None},
            "timecompleted": {"$ne": None},
            "status": {"$ne": RECEIVED},
            "result": {"$ne": None}
        })
        if qr.count() == 1:
            rospy.logwarn("{0} is already scheduled!".format(queryjob_id))
            return ScheduleQueryJobResponse(False)

        # Modify data.
        # Note that this node DOES NOT CREATE a new document.
        data = {
            "timeissued": timeissued,
            "status": RECEIVED,
            "order": None,
            "timestarted": None,
            "timecompleted": None,
            "result": None
        }
        query = {"_id": queryjob_id}
        update = {"$set": data}
        if self._collection.find_and_modify(query, update):
            return ScheduleQueryJobResponse(True)
        else:
            return ScheduleQueryJobResponse(False)

    def schedule_queryjobs_timeissued_FIFO(self):
        ''' Schedule QueryJobs based on timeissued values--first in
        first out. Currently schedule every time this function gets
        called. However, this can be modified since all the outputs are
        written in database.
            Also has some flavor of loadDB. For example, this code is
        setting previously failed RUNNING jobs to FAILED.
        '''

        self._collection.find_and_modify(
            {"status": RUNNING},
            {"$set": {"status": CANCELLED,
                      "timecompleted": dt.utcnow().replace(tzinfo=utc)}}
        )

        queue = []
        query = {"$or": [{"status": RECEIVED}, {"status": SCHEDULED}]}
        qr = self._collection.find(query).sort("timeissued")
        order = 1  # order starts from 1
        for q in qr:
            queryjob_id = q["_id"]
            query = {"_id": q["_id"]}
            update = {"$set": {
                "order": order,
                "status": SCHEDULED
            }}
            if not self._collection.find_and_modify(query, update):
                rospy.logerr("Error while writing schedule results!")
                rospy.signal_shutdown("Bye!")

            # Notify updates.
            msg = QueryJob()
            msg.id = str(queryjob_id)
            self._pub.publish(msg)

            queue.append(queryjob_id)
            order += 1

    def execute_queryjobs(self):

        # Execution loop.
        r = rospy.Rate(1)
        while not rospy.is_shutdown():
            # Make sure server is running.
            rospy.logdebug("Waiting for server...")
            self._ac.wait_for_server()
            rospy.logdebug("Connected!")

            # Schedule if there are new QueryJobs.
            qr = self._collection.find({"status": RECEIVED})
            if qr.count() > 0:
                self.schedule_queryjobs_timeissued_FIFO()

            # Check if there is any QueryJob to execute.
            qr = self._collection.find({"status": SCHEDULED}).sort("order")
            if qr.count() == 0:
                rospy.logdebug(
                    "Waiting for a new QueryJob...")
                r.sleep()
                continue

            # Start a QueryJob.
            queryjob_id = qr[0]["_id"]
            query = {"_id": queryjob_id}
            timestarted = dt.utcnow().replace(tzinfo=utc)
            update = {"$set": {
                "timestarted": timestarted,
                "status": RUNNING
            }}

            # Notify updates.
            q = self._collection.find_and_modify(query, update, new=True)
            if q:
                msg = torosqueryjob(q)
                self._pub.publish(msg)
                goal = RunQueryGoal(msg)
                self._ac.send_goal(goal)
            else:
                rospy.logerr("Error while writing send_goal results!")
                rospy.signal_shutdown("Bye!")

            # Finished the QueryJob.
            self._ac.wait_for_result()
            state = self._ac.get_state()
            result = self._ac.get_result()
            if result is None:
                result = RunQueryResult()
                result.result.text = ""
                result.result.confidence = 0.0
                result.result.img_path = ""

            status = FAILED
            if state == GoalStatus.SUCCEEDED:
                status = SUCCEEDED
            elif state == GoalStatus.PREEMPTED:
                status = CANCELLED

            query = {"_id": queryjob_id}
            timecompleted = dt.utcnow().replace(tzinfo=utc)
            # need to insert new result object at this point of time
            update = {"$set": {
                "timecompleted": timecompleted,
                "status": status,
                "result": {
                    "text": result.result.text,
                    "confidence": result.result.confidence,
                    "img_path": result.result.img_path
                }
            }}
            q = self._collection.find_and_modify(query, update)
            if not q:
                rospy.logerr("Error while writing get_state results!")
                rospy.signal_shutdown("Bye!")
            # Notify updates.
            msg = torosqueryjob(q)
            self._pub.publish(msg)


# ######################################################################
# Main
# ######################################################################
if __name__ == "__main__":
    try:
        node = QueryJobScheduler()
    except rospy.ROSInterruptException:
        pass
